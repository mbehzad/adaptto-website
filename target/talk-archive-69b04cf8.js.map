{"version":3,"file":"talk-archive-69b04cf8.js","sources":["../scripts/services/TalkArchiveFullTextIndex.js","../scripts/services/TalkArchiveItem.js","../scripts/services/TalkArchive.js","../scripts/services/TalkArchiveFilter.js","../blocks/talk-archive/talk-archive.js"],"sourcesContent":["/**\n * Converts talk to indexable string.\n * @typedef {import('./TalkArchiveItem').default} TalkArchiveItem\n * @param {TalkArchiveItem} talk\n */\nfunction talkToText(talk) {\n  return [\n    talk.title ?? '',\n    talk.description ?? '',\n    talk.keywords.join(', '),\n    talk.tags.join(', '),\n    talk.speakers.join(', '),\n  ].join('\\n');\n}\n\n/**\n * Full text index for talk archive.\n * This implements a very simplistic approach by just checking for appearance of\n * search string in talk properties.\n */\nexport default class TalkArchiveFullTextIndex {\n  /**\n   * @type {object[]}\n   */\n  index;\n\n  /**\n   * @typedef {import('./TalkArchiveItem').default} TalkArchiveItem\n   * @param {TalkArchiveItem[]} talks Talks\n   */\n  constructor(talks) {\n    this.index = talks.map((talk) => ({ talk, text: talkToText(talk).toLocaleLowerCase() }));\n  }\n\n  /**\n   * Execute full text search.\n   * @typedef {import('./TalkArchiveItem').default} TalkArchiveItem\n   * @param {string} text Search text\n   * @returns {TalkArchiveItem[]} Search result\n   */\n  search(text) {\n    const searchText = text.toLocaleLowerCase();\n    return this.index\n      .filter((item) => item.text.includes(searchText))\n      .map((item) => item.talk);\n  }\n}\n","/**\n * Item of talk archive.\n * Subset of properties from QueryIndexItem, the array properties are already processed.\n */\nexport default class TalkArchiveItem {\n  /** @type {string} */\n  path;\n\n  /** @type {string} */\n  year;\n\n  /** @type {string} */\n  title;\n\n  /** @type {string} */\n  description;\n\n  /** @type {string[]} */\n  keywords = [];\n\n  /** @type {string[]} */\n  tags = [];\n\n  /** @type {string[]} Talk: Speaker assignment (speaker names or speaker path-names) */\n  speakers = [];\n}\n","import { removeTitleSuffix } from '../utils/metadata.js';\nimport { getYearFromPath } from '../utils/path.js';\nimport { getQueryIndex } from './QueryIndex.js';\nimport TalkArchiveFullTextIndex from './TalkArchiveFullTextIndex.js';\nimport TalkArchiveItem from './TalkArchiveItem.js';\n\n/**\n * Gets a sorted and distinct list of items. Empty items are removed.\n * @param {string[]} items Raw list\n * @returns {string[]} Compiled list\n */\nfunction getDistinctSortedList(items) {\n  const distinctItems = [...new Set(items)]\n    .filter((item) => item !== undefined);\n  return distinctItems.sort();\n}\n\n/**\n * Fetch and filter talks for talk archive.\n */\nexport default class TalkArchive {\n  /**\n   * @typedef {import('./TalkArchiveFilter').default} TalkArchiveFilter\n   * @type {TalkArchiveFilter}\n   */\n  filter;\n\n  /**\n   * @type {TalkArchiveItem[]}\n   */\n  talks;\n\n  /**\n   * @type {TalkArchiveItem[]}\n   */\n  filteredTalks;\n\n  /**\n   * @typedef {import('./TalkArchiveFullTextIndex').default} TalkArchiveFullTextIndex\n   * @type {TalkArchiveFullTextIndex}\n   */\n  index;\n\n  /**\n   * @typedef {import('./QueryIndex').default} QueryIndex\n   * @param {QueryIndex} queryIndex Query index\n   */\n  constructor(queryIndex) {\n    this.talks = queryIndex.getAllTalks()\n      .map((item) => {\n        const talk = new TalkArchiveItem();\n        talk.path = item.path;\n        talk.year = getYearFromPath(item.path)?.toString();\n        talk.title = removeTitleSuffix(item.title);\n        talk.description = item.description;\n        talk.keywords = item.getKeywords();\n        talk.tags = item.getTags();\n        talk.speakers = item.getSpeakers();\n        return talk;\n      })\n      .filter((talk) => talk.speakers.length > 0);\n    this.filteredTalks = this.talks;\n  }\n\n  /**\n   * @typedef {import('./TalkArchiveFilter').default} TalkArchiveFilter\n   * @param {TalkArchiveFilter} filter\n   */\n  applyFilter(filter) {\n    this.filter = filter;\n    if (filter) {\n      this.filteredTalks = this.talks.filter((talk) => filter.matches(talk));\n    } else {\n      this.filteredTalks = this.talks;\n    }\n    this.index = undefined;\n  }\n\n  /**\n   * Get all talks matching the current filter criteria.\n   * @returns {TalkArchiveItem[]} Talk items\n   */\n  getFilteredTalks() {\n    return this.filteredTalks;\n  }\n\n  /**\n   * Get all talks matching the current filter criteria and the given fill text expression.\n   * @param {string} fullText Full text expression\n   * @returns {TalkArchiveItem[]} Talk items\n   */\n  getFilteredTalksFullTextSearch(fullText) {\n    if (!this.index) {\n      this.index = new TalkArchiveFullTextIndex(this.filteredTalks);\n    }\n    return this.index.search(fullText);\n  }\n\n  /**\n   * Get all tag filter options, sorted ascending.\n   * @returns {string[]} Tag names\n   */\n  getTagFilterOptions() {\n    return getDistinctSortedList(this.talks\n      .flatMap((talk) => talk.tags));\n  }\n\n  /**\n   * Get all year filter options, sorted descending.\n   * @returns {string[]} Years\n   */\n  getYearFilterOptions() {\n    return getDistinctSortedList(this.talks\n      .map((talk) => talk.year))\n      .reverse();\n  }\n\n  /**\n   * Get all speaker filter options, sorted ascending.\n   * @returns {string[]} Speaker names\n   */\n  getSpeakerFilterOptions() {\n    return getDistinctSortedList(this.talks\n      .flatMap((talk) => talk.speakers));\n  }\n}\n\n/**\n * Get Query Index based on query-index.json.\n */\nexport async function getTalkArchive() {\n  const queryIndex = await getQueryIndex();\n  return new TalkArchive(queryIndex);\n}\n","const validFilterCategory = ['tags', 'years', 'speakers'];\n\n/**\n * Builds list of filter options with URI encoding.\n * @param {string[]} items\n * @returns {string} Encoded comma-separated options\n */\nfunction buildHashFilterOptions(items) {\n  return items.map((item) => encodeURIComponent(item)).join(',');\n}\n\n/**\n * Filter criteria for talk archive.\n */\nexport default class TalkArchiveFilter {\n  /**\n   * Filter by tags.\n   * @type {string[]}\n   */\n  tags;\n\n  /**\n   * Filter by years.\n   * @type {string[]}\n   */\n  years;\n\n  /**\n   * Filter by speaker names.\n   * @type {string[]}\n   */\n  speakers;\n\n  /**\n   * @typedef {import('./TalkArchiveItem').default} TalkArchiveItem\n   * @param {TalkArchiveItem} talk Talk\n   * @returns {boolean} true if talk matches\n   */\n  matches(talk) {\n    if (this.tags) {\n      if (!this.tags.find((tag) => talk.tags.includes(tag))) {\n        return false;\n      }\n    }\n    if (this.years) {\n      if (!this.years.includes(talk.year)) {\n        return false;\n      }\n    }\n    if (this.speakers) {\n      if (!this.speakers.find((speaker) => talk.speakers.includes(speaker))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Builds a hash string reflecting the current filter options.\n   * @returns {string} Hash string\n   */\n  buildHash() {\n    const filters = [];\n    if (this.tags) {\n      filters.push(`tags=${buildHashFilterOptions(this.tags)}`);\n    }\n    if (this.years) {\n      filters.push(`years=${buildHashFilterOptions(this.years)}`);\n    }\n    if (this.speakers) {\n      filters.push(`speakers=${buildHashFilterOptions(this.speakers)}`);\n    }\n    return `#${filters.join('/')}`;\n  }\n}\n\n/**\n * Build filter options from hash.\n * @param {string} hash Window location hash\n * @returns {TalkArchiveFilter} filter\n */\nexport function getFilterFromHash(hash) {\n  const filter = new TalkArchiveFilter();\n  const filterStrings = hash.substring(1).split('/');\n  filterStrings.forEach((filterString) => {\n    const filterParts = filterString.split('=');\n    if (filterParts.length === 2) {\n      const filterName = filterParts[0];\n      const filterOptions = filterParts[1].split(',').map((item) => decodeURIComponent(item));\n      if (validFilterCategory.includes(filterName) && filterOptions.length > 0) {\n        filter[filterName] = filterOptions;\n      }\n    }\n  });\n  return filter;\n}\n","import { getTalkArchive } from '../../scripts/services/TalkArchive.js';\nimport { getFilterFromHash } from '../../scripts/services/TalkArchiveFilter.js';\nimport { append } from '../../scripts/utils/dom.js';\nimport html from '../../scripts/utils/htmlTemplateTag.js';\nimport { getYearFromPath } from '../../scripts/utils/path.js';\n\nconst filterCategories = [\n  {\n    category: 'tags',\n    label: 'Tags',\n    archiveMethod: 'getTagFilterOptions',\n    collapsible: false,\n  },\n  {\n    category: 'years',\n    label: 'Year',\n    archiveMethod: 'getYearFilterOptions',\n    collapsible: true,\n  },\n  {\n    category: 'speakers',\n    label: 'Speaker',\n    archiveMethod: 'getSpeakerFilterOptions',\n    collapsible: true,\n  },\n];\n\n/**\n * Renders talk archive filter options and result depending on current filter hash.\n * @typedef {import('../../scripts/services/TalkArchive').default} TalkArchive\n * @param {Element} block\n * @param {TalkArchive} talkArchive\n * @param {boolean} applyFilter Re-apply filters from hash.\n */\nfunction displayFilteredTalks(block, talkArchive, applyFilter) {\n  if (applyFilter) {\n    talkArchive.applyFilter(getFilterFromHash(window.location.hash));\n  }\n\n  // full text\n  const fullText = block.querySelector('.search input').value.trim();\n\n  // result table\n  const tbody = block.querySelector('.result table tbody');\n  tbody.innerHTML = '';\n  const talks = fullText !== ''\n    ? talkArchive.getFilteredTalksFullTextSearch(fullText)\n    : talkArchive.getFilteredTalks();\n\n  if (talks.length > 0) {\n    talks.forEach((talk) => {\n      tbody.insertAdjacentHTML('beforeend', html`<tr>\n        <td>${getYearFromPath(talk.path)}</td>\n        <td><a href=\"${talk.path}\">${talk.title}</a></td>\n        <td>${talk.speakers.join(', ')}</td>\n      </tr>`);\n    });\n  } else {\n    tbody.insertAdjacentHTML('beforeend', html`<tr class=\"no-result\">\n      <td colspan=\"3\">No matching talk found.</td>\n    </tr>`);\n  }\n}\n\n/**\n * Add filter category options.\n * @param {Element} parent Parent element\n * @param {string} categoryLabel Category label\n * @param {string[]} items All items\n * @param {string[]} selectedItems Selected items\n * @param {boolean} collapsible Options list is collapsible\n * @returns {Element} Filter category element\n */\nfunction addFilterCategory(parent, categoryLabel, items, selectedItems, collapsible) {\n  const div = append(parent, 'div', 'filter-category');\n  const span = append(div, 'span', 'category');\n  span.textContent = categoryLabel;\n  const ul = append(div, 'ul');\n\n  items.forEach((item) => {\n    const li = append(ul, 'li');\n    const label = append(li, 'label');\n    const input = append(label, 'input');\n    input.type = 'checkbox';\n    input.value = item;\n    if (selectedItems && selectedItems.includes(item)) {\n      input.checked = true;\n    }\n    label.append(item);\n  });\n\n  if (collapsible && items.length > 5) {\n    ul.classList.add('collapsible');\n    if (!selectedItems || selectedItems.length === 0) {\n      // collapse by default, unless there is any item selected from this filter option\n      ul.classList.add('collapsed');\n    }\n\n    ul.insertAdjacentHTML('beforeend', html`\n      <li class=\"collapse-toggle more\"><a href=\"\">more...</a></li>\n      <li class=\"collapse-toggle less\"><a href=\"\">less...</a></li>`);\n  }\n\n  return div;\n}\n\n/**\n * Add filter categories.\n * @typedef {import('../../scripts/services/TalkArchive').default} TalkArchive\n * @param {Element} block\n * @param {TalkArchive} talkArchive\n */\nfunction addFilterCategories(block, talkArchive) {\n  const filterDiv = block.querySelector('.filter');\n\n  filterCategories.forEach((filterCategory) => {\n    const categoryDiv = addFilterCategory(\n      filterDiv,\n      filterCategory.label,\n      talkArchive[filterCategory.archiveMethod](),\n      talkArchive.filter[filterCategory.category],\n      filterCategory.collapsible,\n    );\n\n    // enable filter state changes\n    categoryDiv.querySelectorAll('input[type=checkbox]').forEach((input) => {\n      input.addEventListener('change', () => {\n        let currentlySelectedItems = Array.from(categoryDiv.querySelectorAll('input[type=checkbox]'))\n          .filter((item) => item.checked)\n          .map((item) => item.value);\n        if (currentlySelectedItems.length === 0) {\n          currentlySelectedItems = undefined;\n        }\n        const filter = getFilterFromHash(window.location.hash);\n        filter[filterCategory.category] = currentlySelectedItems;\n        window.history.replaceState(null, null, filter.buildHash());\n        displayFilteredTalks(block, talkArchive, true);\n      });\n    });\n  });\n\n  // enable toggles for collapsible filter lists\n  filterDiv.querySelectorAll('ul.collapsible').forEach((ul) => {\n    ul.querySelectorAll(' li.collapse-toggle a').forEach((a) => {\n      a.addEventListener('click', (e) => {\n        e.preventDefault();\n        ul.classList.toggle('collapsed');\n      });\n    });\n  });\n}\n\n/**\n * Talk archive.\n * @param {Element} block\n */\nexport default async function decorate(block) {\n  const talkArchive = await getTalkArchive();\n\n  // prepare archive markup\n  block.innerHTML = html`\n      <div class=\"search\">\n        <input type=\"search\" placeholder=\"Search\">\n      </div>\n      <div class=\"filter\">\n      </div>\n      <div class=\"result\">\n        <table>\n          <thead>\n            <tr>\n              <th>Year</th>\n              <th>Talk</th>\n              <th>Speaker</th>\n            </tr>\n          </thead>\n          <tbody>\n          </tbody>\n        </table>\n      </div>`;\n\n  // fire full text search when entering text (with 0.5sec delay)\n  let typingTimer;\n  block.querySelector('.search input').addEventListener('input', () => {\n    clearInterval(typingTimer);\n    typingTimer = setTimeout(() => displayFilteredTalks(block, talkArchive, false), 500);\n  });\n\n  // react to stage changes via hash\n  window.addEventListener('hashchange', () => displayFilteredTalks(block, talkArchive, true));\n  displayFilteredTalks(block, talkArchive, true);\n\n  // filter\n  addFilterCategories(block, talkArchive);\n}\n"],"names":["talkToText","talk","title","description","keywords","join","tags","speakers","TalkArchiveFullTextIndex","index","constructor","talks","this","map","text","toLocaleLowerCase","search","searchText","filter","item","includes","TalkArchiveItem","path","year","getDistinctSortedList","items","Set","undefined","sort","TalkArchive","filteredTalks","queryIndex","getAllTalks","getYearFromPath","toString","removeTitleSuffix","getKeywords","getTags","getSpeakers","length","applyFilter","matches","getFilteredTalks","getFilteredTalksFullTextSearch","fullText","getTagFilterOptions","flatMap","getYearFilterOptions","reverse","getSpeakerFilterOptions","validFilterCategory","buildHashFilterOptions","encodeURIComponent","TalkArchiveFilter","years","find","tag","speaker","buildHash","filters","push","getFilterFromHash","hash","substring","split","forEach","filterString","filterParts","filterName","filterOptions","decodeURIComponent","filterCategories","category","label","archiveMethod","collapsible","displayFilteredTalks","block","talkArchive","window","location","querySelector","value","trim","tbody","innerHTML","insertAdjacentHTML","html","addFilterCategories","filterDiv","filterCategory","categoryDiv","parent","categoryLabel","selectedItems","div","append","textContent","ul","li","input","type","checked","classList","add","addFilterCategory","querySelectorAll","addEventListener","currentlySelectedItems","Array","from","history","replaceState","a","e","preventDefault","toggle","async","decorate","getQueryIndex","getTalkArchive","typingTimer","clearInterval","setTimeout"],"mappings":"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"}